# 轮子
## 单例类
1. Singleton.h
2. 使用pthread库的pthread_once来保证线程安全，单例创建函数智慧被调用一次
3. 单例类只能调用默认的构造函数，若需要定制T的构造，需使用模板特化
4. 没有考虑对象的销毁，程序退出了自动析构对象资源（前提是程序没有使用不能由操作系统自动关闭释放的资源，比如：跨进程的互斥锁

## SGI_STL_MEMPOOL
1. 移植SGI_STL的内存池
2. 采用指针数组。每个指针指向块大小不同的内存池。
3. 内存池的大小【按8字节对齐】从【8，128】大于128byte的内存开辟直接使用malloc开辟
### 优势
1. 对于每个字节数的chunk块的分配，都是给出一部分使用，另外一部分作为备用，这个备用的内存块，可以给当前字节数的内存分配使用，也可以给其他的字节数使用.内存池中的指针start_free and end_Free记录着空闲的内存块的收尾地址
2. 对于备用内存池划分完chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的没被使用的内存块找到合适的字节大小的内存池，放进去，榨干备用内存池。
```c++
 // Try to make use of the left-over piece.
        if (__bytes_left > 0) {
            _Obj* __STL_VOLATILE* __my_free_list =
                        _S_free_list + _S_freelist_index(__bytes_left); // 找合适大小的内存池

            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;
            *__my_free_list = (_Obj*)_S_start_free; // 放进去
        }

```

3. 当指定字节数的内存分配失败后，有一个异常处理过程，首先先去bytes ~ 128 的每个内存池中找有没空闲的内存块，如果有借一个。如果上面操作失败， 还会调用一个预先设置好的malloc内存分配失败的回调函数，没设置就会抛出 bad_alloc异常。 如果设置了，就会死循环的调用这个函数。直到获取到可用内存块 